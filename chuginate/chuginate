#!/usr/bin/python

import sys
import re
import os
import io

if len(sys.argv) != 2 and len(sys.argv) != 3:
    print "usage: chuginate chugin_name [destination_directory]"
    sys.exit(-1)

chugin_name = sys.argv[1]
if len(sys.argv) >= 3:
    dest_dir = sys.argv[2]
else:
    dest_dir = sys.argv[1]
    os.mkdir(dest_dir)

chugin_lcname = chugin_name.lower()
chugin_ucname = chugin_name.upper()
chugin_initials = re.sub('[a-z]', '', chugin_name).lower()
if len(chugin_initials) == 0:
    chugin_initials = chugin_name[0];

def substitute(text):
    global chugin_name, chugin_lcname, chugin_ucname, chugin_initials
    text = re.sub('\%\(CHUGIN_NAME\)\%', chugin_name, text)
    text = re.sub('\%\(CHUGIN_LCNAME\)\%', chugin_lcname, text)
    text = re.sub('\%\(CHUGIN_UCNAME\)\%', chugin_ucname, text)
    text = re.sub('\%\(CHUGIN_INITIALS\)\%', chugin_initials, text)
    return text

# print "name: %s lc: %s initials: %s" % (chugin_name, chugin_lcname, chugin_initials)

code = dict()
filepath = dict()
newlines = dict()

code['cpp'] = u'''//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>

// declaration of chugin constructor
CK_DLL_CTOR(%(CHUGIN_LCNAME)%_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(%(CHUGIN_LCNAME)%_dtor);

// example of getter/setter
CK_DLL_MFUN(%(CHUGIN_LCNAME)%_setParam);
CK_DLL_MFUN(%(CHUGIN_LCNAME)%_getParam);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(%(CHUGIN_LCNAME)%_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT %(CHUGIN_LCNAME)%_data_offset = 0;


// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class %(CHUGIN_NAME)%
{
public:
    // constructor
    %(CHUGIN_NAME)%( t_CKFLOAT fs)
    {
        m_param = 0;
    }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into Chugin
        return in;
    }

    // set parameter example
    float setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    // get parameter example
    float getParam() { return m_param; }
    
private:
    // instance data
    float m_param;
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( %(CHUGIN_NAME)% )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "%(CHUGIN_NAME)%");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "%(CHUGIN_NAME)%", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, %(CHUGIN_LCNAME)%_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, %(CHUGIN_LCNAME)%_dtor);
    
    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, %(CHUGIN_LCNAME)%_tick, NULL, 1, 1);
    
    // NOTE: if this is to be a UGen with more than 1 channel, 
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    // example of adding setter method
    QUERY->add_mfun(QUERY, %(CHUGIN_LCNAME)%_setParam, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, %(CHUGIN_LCNAME)%_getParam, "float", "param");
    
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    %(CHUGIN_LCNAME)%_data_offset = QUERY->add_mvar(QUERY, "int", "@%(CHUGIN_INITIALS)%_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(%(CHUGIN_LCNAME)%_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, %(CHUGIN_LCNAME)%_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    %(CHUGIN_NAME)% * bcdata = new %(CHUGIN_NAME)%(API->vm->get_srate());
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, %(CHUGIN_LCNAME)%_data_offset) = (t_CKINT) bcdata;
}


// implementation for the destructor
CK_DLL_DTOR(%(CHUGIN_LCNAME)%_dtor)
{
    // get our c++ class pointer
    %(CHUGIN_NAME)% * bcdata = (%(CHUGIN_NAME)% *) OBJ_MEMBER_INT(SELF, %(CHUGIN_LCNAME)%_data_offset);
    // check it
    if( bcdata )
    {
        // clean up
        delete bcdata;
        OBJ_MEMBER_INT(SELF, %(CHUGIN_LCNAME)%_data_offset) = 0;
        bcdata = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(%(CHUGIN_LCNAME)%_tick)
{
    // get our c++ class pointer
    %(CHUGIN_NAME)% * c = (%(CHUGIN_NAME)% *) OBJ_MEMBER_INT(SELF, %(CHUGIN_LCNAME)%_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(c) *out = c->tick(in);

    // yes
    return TRUE;
}


// example implementation for setter
CK_DLL_MFUN(%(CHUGIN_LCNAME)%_setParam)
{
    // get our c++ class pointer
    %(CHUGIN_NAME)% * bcdata = (%(CHUGIN_NAME)% *) OBJ_MEMBER_INT(SELF, %(CHUGIN_LCNAME)%_data_offset);
    // set the return value
    RETURN->v_float = bcdata->setParam(GET_NEXT_FLOAT(ARGS));
}


// example implementation for getter
CK_DLL_MFUN(%(CHUGIN_LCNAME)%_getParam)
{
    // get our c++ class pointer
    %(CHUGIN_NAME)% * bcdata = (%(CHUGIN_NAME)% *) OBJ_MEMBER_INT(SELF, %(CHUGIN_LCNAME)%_data_offset);
    // set the return value
    RETURN->v_float = bcdata->getParam();
}
'''
code['makefile'] = u'''
# chugin name
CHUGIN_NAME=%(CHUGIN_NAME)%

# all of the c/cpp files that compose this chugin
C_MODULES=
CXX_MODULES=%(CHUGIN_NAME)%.cpp

# where the chuck headers are
CK_SRC_PATH?=../chuck/include/


# ---------------------------------------------------------------------------- #
# you won't generally need to change anything below this line for a new chugin #
# ---------------------------------------------------------------------------- #

# default target: print usage message and quit
current: 
	@echo "[chuck build]: please use one of the following configurations:"
	@echo "   make linux, make osx, or make win32"

ifneq ($(CK_TARGET),)
.DEFAULT_GOAL:=$(CK_TARGET)
ifeq ($(MAKECMDGOALS),)
MAKECMDGOALS:=$(.DEFAULT_GOAL)
endif
endif

.PHONY: osx linux linux-oss linux-jack linux-alsa win32
osx linux linux-oss linux-jack linux-alsa win32: all

CC=gcc
CXX=gcc
LD=g++

CHUGIN_PATH=/usr/lib/chuck

ifneq (,$(strip $(filter osx bin-dist-osx,$(MAKECMDGOALS))))
include makefile.osx
endif

ifneq (,$(strip $(filter linux,$(MAKECMDGOALS))))
include makefile.linux
endif

ifneq (,$(strip $(filter linux-oss,$(MAKECMDGOALS))))
include makefile.linux
endif

ifneq (,$(strip $(filter linux-jack,$(MAKECMDGOALS))))
include makefile.linux
endif

ifneq (,$(strip $(filter linux-alsa,$(MAKECMDGOALS))))
include makefile.linux
endif

ifneq (,$(strip $(filter win32,$(MAKECMDGOALS))))
include makefile.win32
endif

ifneq ($(CHUCK_DEBUG),)
FLAGS+= -g
else
FLAGS+= -O3
endif

ifneq ($(CHUCK_STRICT),)
FLAGS+= -Wall
endif

# default: build a dynamic chugin
CK_CHUGIN_STATIC?=0

ifeq ($(CK_CHUGIN_STATIC),0)
SUFFIX=.chug
else
SUFFIX=.schug
FLAGS+= -D__CK_DLL_STATIC__
endif

C_OBJECTS=$(addsuffix .o,$(basename $(C_MODULES)))
CXX_OBJECTS=$(addsuffix .o,$(basename $(CXX_MODULES)))

CHUG=$(addsuffix $(SUFFIX),$(CHUGIN_NAME))

all: $(CHUG)

$(CHUG): $(C_OBJECTS) $(CXX_OBJECTS)
ifeq ($(CK_CHUGIN_STATIC),0)
	$(LD) $(LDFLAGS) -o $@ $^
else
	ar rv $@ $^
	ranlib $@
endif

$(C_OBJECTS): %.o: %.c
	$(CC) $(FLAGS) -c -o $@ $<

$(CXX_OBJECTS): %.o: %.cpp $(CK_SRC_PATH)/chuck_dl.h
	$(CXX) $(FLAGS) -c -o $@ $<

install: $(CHUG)
	mkdir -p $(CHUGIN_PATH)
	cp $^ $(CHUGIN_PATH)
	chmod 755 $(CHUGIN_PATH)/$(CHUG)

clean: 
	rm -rf $(C_OBJECTS) $(CXX_OBJECTS) $(CHUG)

'''
code['makefile.osx'] = u'''
ARCHS?=i386 x86_64
ARCHOPTS=$(addprefix -arch ,$(ARCHS))

FLAGS=-D__MACOSX_CORE__ -I$(CK_SRC_PATH) $(ARCHOPTS) -fPIC
LDFLAGS=-bundle -lstdc++ $(ARCHOPTS)

LD=clang++
CXX=clang++
'''
code['makefile.linux'] = u'''
CHUGIN_PATH=/usr/lib/chuck

FLAGS=-D__LINUX_ALSA__ -I$(CK_SRC_PATH) -fPIC
LDFLAGS=-shared -lstdc++

LD=gcc
CXX=g++
'''
code['makefile.win32'] = u'''
FLAGS=-D__WINDOWS_DS_ -D__WINDOWS_PTHREAD__ -I$(CK_SRC_PATH)
LDFLAGS=-shared -lstdc++

CXX=g++
LD=g++
'''
code['.dsw'] = u'''Microsoft Developer Studio Workspace File, Format Version 6.00
# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!

###############################################################################

Project: "%(CHUGIN_NAME)%"=.\%(CHUGIN_NAME)%.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
}}}

###############################################################################

Global:

Package=<5>
{{{
}}}

Package=<3>
{{{
}}}

###############################################################################

'''
code['.dsp'] = u'''# Microsoft Developer Studio Project File - Name="%(CHUGIN_NAME)%" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102

CFG=%(CHUGIN_NAME)% - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "%(CHUGIN_NAME)%.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "%(CHUGIN_NAME)%.mak" CFG="%(CHUGIN_NAME)% - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "%(CHUGIN_NAME)% - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE "%(CHUGIN_NAME)% - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "%(CHUGIN_NAME)% - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "%(CHUGIN_UCNAME)%_EXPORTS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /MT /W3 /GX /O2 /I "..\chuck\include" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "__PLATFORM_WIN32__" /D "__WINDOWS_DS__" /FD /c
# SUBTRACT CPP /YX /Yc /Yu
# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x409 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:"Release/%(CHUGIN_NAME)%.chug"

!ELSEIF  "$(CFG)" == "%(CHUGIN_NAME)% - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "%(CHUGIN_UCNAME)%_EXPORTS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "..\chuck\include" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "__PLATFORM_WIN32__" /D "__WINDOWS_DS__" /FD /GZ /c
# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x409 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:"Debug/%(CHUGIN_NAME)%.chug" /pdbtype:sept

!ENDIF 

# Begin Target

# Name "%(CHUGIN_NAME)% - Win32 Release"
# Name "%(CHUGIN_NAME)% - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\%(CHUGIN_NAME)%.cpp

!IF  "$(CFG)" == "%(CHUGIN_NAME)% - Win32 Release"

!ELSEIF  "$(CFG)" == "%(CHUGIN_NAME)% - Win32 Debug"

# ADD CPP /D "__WINDOWS_DS__"

!ENDIF 

# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project
'''

filepath['cpp'] = "%s/%s.cpp" % (dest_dir, chugin_name)
filepath['makefile'] = "%s/makefile" % (dest_dir)
filepath['makefile.osx'] = "%s/makefile.osx" % (dest_dir)
filepath['makefile.linux'] = "%s/makefile.linux" % (dest_dir)
filepath['makefile.win32'] = "%s/makefile.win32" % (dest_dir)
filepath['.dsw'] = "%s/%s.dsw" % (dest_dir, chugin_name)
filepath['.dsp'] = "%s/%s.dsp" % (dest_dir, chugin_name)

newlines['.dsw'] = '\r\n'
newlines['.dsp'] = '\r\n'

code['cpp'] = substitute(code['cpp'])
code['makefile'] = substitute(code['makefile'])
code['.dsw'] = substitute(code['.dsw'])
code['.dsp'] = substitute(code['.dsp'])

for key in code:
    if key in newlines:
        nl = newlines[key]
    else:
        nl = '\n'
    f = io.open(filepath[key], "wt", newline=nl)
    f.write(code[key])
    f.close()


    
    
