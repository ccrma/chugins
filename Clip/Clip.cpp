/*
 * Clip UGen - clips audio signals
 * based on Pure Data clip~
 * 
 * @author      Mario Buoninfante
 * @year        2020
*/

//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>
#include <math.h>


CK_DLL_CTOR(clip_ctor);
CK_DLL_DTOR(clip_dtor);
CK_DLL_MFUN(clip_setRange);
CK_DLL_MFUN(clip_getLow);
CK_DLL_MFUN(clip_getHi);
CK_DLL_TICK(clip_tick);

t_CKINT clip_data_offset = 0;


class Clip
{
public:


// constructor
Clip()
{
    low = -1;
    hi  = 1;
}

// for Chugins extending UGen
SAMPLE tick ( SAMPLE in )
{
    // default: this passes whatever input is patched into Chugin
    if(in < low)        return low;
    else if(in > hi)    return hi;
    else                return in;
}

float setLow(float x)
{
    low = x;
    return x;
}

float setHi(float x)
{
    hi = x;
    return x;
}

float getLow()
{
    return low;
}

float getHi()
{
    return hi;
}

private:
float low;
float hi;
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Clip )
{
        QUERY->setname(QUERY, "Clip");

        QUERY->begin_class(QUERY, "Clip", "UGen");
        
        QUERY->add_ctor(QUERY, clip_ctor);
        QUERY->add_dtor(QUERY, clip_dtor);
        
        QUERY->add_ugen_func(QUERY, clip_tick, NULL, 1, 1);

        // set methods
        QUERY->add_mfun(QUERY, clip_setRange, "int", "range");
        QUERY->add_arg(QUERY, "float", "arg");
        QUERY->add_arg(QUERY, "float", "arg2");
        
        // get methods
        QUERY->add_mfun(QUERY, clip_getLow, "float", "getLow");
        QUERY->add_mfun(QUERY, clip_getHi, "float", "getHi");

        QUERY->end_class(QUERY);

        return TRUE;
}

CK_DLL_CTOR(clip_ctor)
{
        OBJ_MEMBER_INT(SELF, clip_data_offset) = 0;
        Clip * c_obj = new Clip;
        OBJ_MEMBER_INT(SELF, clip_data_offset) = (t_CKINT) c_obj;
}

CK_DLL_DTOR(clip_dtor)
{
        Clip * c_obj = (Clip *) OBJ_MEMBER_INT(SELF, clip_data_offset);
        if( c_obj )
        {
                // clean up
                delete c_obj;
                OBJ_MEMBER_INT(SELF, clip_data_offset) = 0;
                c_obj = NULL;
        }
}

CK_DLL_TICK(clip_tick)
{
        Clip * c_obj = (Clip *) OBJ_MEMBER_INT(SELF, clip_data_offset);
        if(c_obj) *out = c_obj->tick(in);
        return TRUE;
}

CK_DLL_MFUN(clip_setRange)
{
        Clip * c_obj = (Clip *) OBJ_MEMBER_INT(SELF, clip_data_offset);
        c_obj->setLow(GET_NEXT_FLOAT(ARGS));        
        c_obj->setHi(GET_NEXT_FLOAT(ARGS));
        RETURN->v_int = 1;
}

CK_DLL_MFUN(clip_getLow)
{
        Clip * c_obj = (Clip *) OBJ_MEMBER_INT(SELF, clip_data_offset);
        RETURN->v_float = c_obj->getLow();
}

CK_DLL_MFUN(clip_getHi)
{
        Clip * c_obj = (Clip *) OBJ_MEMBER_INT(SELF, clip_data_offset);
        RETURN->v_float = c_obj->getHi();
}
