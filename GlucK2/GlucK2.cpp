//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>


#ifdef __MACOSX_CORE__
// note: for mac only
#include <GLUT/glut.h>
#else
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#endif

Chuck_DL_MTHook * g_hook = NULL;

GLsizei g_width = 1024;
GLsizei g_height = 768;

GLsizei g_lastWindowedWidth = g_width;
GLsizei g_lastWindowedHeight = g_height;

//-----------------------------------------------------------------------------
// Name: reshapeFunc( )
// Desc: called when window size changes
//-----------------------------------------------------------------------------
void reshapeFunc( GLsizei w, GLsizei h )
{
    // save the new window size
    g_width = w; g_height = h;
    // map the view port to the client area
    glViewport( 0, 0, w, h );
}


void toggleFullScreen()
{
    static bool isFullScreen = false;
    
    if(!isFullScreen)
    {
        g_lastWindowedWidth = g_width;
        g_lastWindowedHeight = g_height;
        
        glutFullScreen();
        
        isFullScreen = true;
    }
    else
    {
        glutReshapeWindow(g_lastWindowedWidth, g_lastWindowedHeight);
        
        isFullScreen = false;
    }
}


//-----------------------------------------------------------------------------
// Name: keyboardFunc( )
// Desc: key event
//-----------------------------------------------------------------------------
void keyboardFunc( unsigned char key, int x, int y )
{
    int mod = glutGetModifiers();
    
    if(mod & GLUT_ACTIVE_CTRL)
    {
        switch( key )
        {
            case 'Q':
            case 'q':
                exit(1);
                break;
                
            case 'f':
            case 'F':
                toggleFullScreen();
                break;
        }
    }
}



//-----------------------------------------------------------------------------
// Name: mouseFunc( )
// Desc: handles mouse stuff
//-----------------------------------------------------------------------------
void mouseFunc( int button, int state, int x, int y )
{
}


void motionFunc(int x, int y)
{
}




//-----------------------------------------------------------------------------
// Name: idleFunc( )
// Desc: callback from GLUT
//-----------------------------------------------------------------------------
void idleFunc( )
{
}


void timerFunc(int value)
{
    glutPostRedisplay();
    
    glutTimerFunc(1000/30, timerFunc, 1);
}




//-----------------------------------------------------------------------------
// Name: displayFunc( )
// Desc: callback function invoked to draw the client area
//-----------------------------------------------------------------------------
void displayFunc( )
{
    glClearColor( 1.0, 0.0, 0.0, 1.0 );
    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    
    glFlush( );
    glutSwapBuffers( );
}


t_CKBOOL glut_main_thread_hook( void * bindle )
{
    int argc = 1;
    char *argv[] = { "chuck" };
    
    // initialize GLUT
    glutInit( &argc, argv );
    // double buffer, use rgb color, enable depth buffer
    glutInitDisplayMode( GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH );
    // initialize the window size
    glutInitWindowSize( g_width, g_height );
    // set the window postion
    glutInitWindowPosition( 100, 100 );
    // create the window
    glutCreateWindow( "GlucK2" );
    
    // set the idle function - called when idle
    //glutIdleFunc( idleFunc );
    // set the display function - called when redrawing
    glutDisplayFunc( displayFunc );
    // set the reshape function - called when client area changes
    glutReshapeFunc( reshapeFunc );
    // set the keyboard function - called on keyboard events
    glutKeyboardFunc( keyboardFunc );
    // set the mouse function - called on mouse stuff
    glutMouseFunc( mouseFunc );
    glutMotionFunc( motionFunc );
    glutPassiveMotionFunc(motionFunc);
    
    glutTimerFunc(1000/30, timerFunc, 1);

    glutMainLoop();
}

t_CKBOOL glut_main_thread_quit( void * bindle )
{
}

class GlucK2
{
public:
    GlucK2() { }
};

// declaration of chugin constructor
CK_DLL_CTOR(gluck2_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(gluck2_dtor);

// this is a special offset reserved for Chugin internal data
t_CKINT gluck2_data_offset = 0;


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( GlucK2 )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "GlucK2");
    
    g_hook = QUERY->create_main_thread_hook(QUERY, glut_main_thread_hook,
                                            glut_main_thread_quit, NULL);
    
    g_hook->activate(g_hook);
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "GlucK2", "Object");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, gluck2_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, gluck2_dtor);
    
    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(gluck2_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, gluck2_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    GlucK2 * bcdata = new GlucK2();
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, gluck2_data_offset) = (t_CKINT) bcdata;
}


// implementation for the destructor
CK_DLL_DTOR(gluck2_dtor)
{
    // get our c++ class pointer
    GlucK2 * bcdata = (GlucK2 *) OBJ_MEMBER_INT(SELF, gluck2_data_offset);
    // check it
    if( bcdata )
    {
        // clean up
        delete bcdata;
        OBJ_MEMBER_INT(SELF, gluck2_data_offset) = 0;
        bcdata = NULL;
    }
}


