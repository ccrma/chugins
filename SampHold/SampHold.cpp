/*
 * SampHold UGen - sample and hold audio signals
 * samples signal connected to chan(0) every time signal
 * connected to chan(1) decreases in amplitude
 * 
 * @author      Mario Buoninfante
 * @year        2020
*/

//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>

CK_DLL_CTOR(samphold_ctor);
CK_DLL_DTOR(samphold_dtor);

CK_DLL_TICKF(samphold_tickf);

t_CKINT samphold_data_offset = 0;


class SampHold
{
public:
    // constructor
    SampHold( t_CKFLOAT fs)
    {
        prev_in = 0;
        prev_ctl_in = 0;
    }

    // for Chugins extending UGen
    SAMPLE tickf( SAMPLE * in, SAMPLE * out, int nframes )
    {
        // memset(out, 0, sizeof(SAMPLE)*2*nframes);

        for (int i=0; i < nframes; i+=2)
        {
            if  (in[i+1] < prev_ctl_in)
            {
                out[i]      = in[i];
                out[i+1]    = in[i];
                prev_in     = in[i];
                prev_ctl_in = in[i+1];
            }
            else
            {
                out[i]      = prev_in;
                out[i+1]    = prev_in;
                prev_ctl_in = in[i+1];
            }
        }

        return 1;
    }
    
private:
    // instance data
    t_CKFLOAT prev_ctl_in;
    t_CKFLOAT prev_in;
};

CK_DLL_QUERY( SampHold )
{
    QUERY->setname(QUERY, "SampHold");
    
    QUERY->begin_class(QUERY, "SampHold", "UGen");

    QUERY->add_ctor(QUERY, samphold_ctor);
    QUERY->add_dtor(QUERY, samphold_dtor);
    
    QUERY->add_ugen_funcf(QUERY, samphold_tickf, NULL, 2, 1);
    
    samphold_data_offset = QUERY->add_mvar(QUERY, "int", "@sh_data", false);

    QUERY->end_class(QUERY);

    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(samphold_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, samphold_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    SampHold * sh_obj = new SampHold(API->vm->get_srate(API, SHRED));
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, samphold_data_offset) = (t_CKINT) sh_obj;
}


// implementation for the destructor
CK_DLL_DTOR(samphold_dtor)
{
    // get our c++ class pointer
    SampHold * sh_obj = (SampHold *) OBJ_MEMBER_INT(SELF, samphold_data_offset);
    // check it
    if( sh_obj )
    {
        // clean up
        delete sh_obj;
        OBJ_MEMBER_INT(SELF, samphold_data_offset) = 0;
        sh_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICKF(samphold_tickf)
{
    // get our c++ class pointer
    SampHold * sh_obj = (SampHold *) OBJ_MEMBER_INT(SELF, samphold_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(sh_obj) sh_obj->tickf(in, out, nframes);

    // yes
    return TRUE;
}
