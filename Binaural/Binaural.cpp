//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chugin.h"

// general includes
#include <stdio.h>
#include <limits.h>

// STL includes
#include <iostream>
#include <string>
using namespace std;




// declaration of chugin constructor
CK_DLL_CTOR(binaural_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(binaural_dtor);

// functions
CK_DLL_MFUN(binaural_loadDefault);
CK_DLL_MFUN(binaural_loadSet);
CK_DLL_MFUN(binaural_load);

// multi-channel audio synthesis tick function
CK_DLL_TICKF(binaural_tickf);

// this is a special offset reserved for Chugin internal data
t_CKINT binaural_data_offset = 0;




//-----------------------------------------------------------------------------
// name: class Binaural
// desc: binaural implementation
//-----------------------------------------------------------------------------
class Binaural
{
public:
    // constructor
    Binaural()
    {
        // output is stereo
        m_chans = 2;
    }

    // for Chugins extending UGen
    void tick( SAMPLE * in, SAMPLE * out, int nframes )
    {
        // for now pass though
        for( int i = 0; i < nframes; i++ )
        {
            out[i*2] = in[0];
            out[i*2+1] = in[0];
        }
    }
    
    // load
    bool load( t_CKFLOAT elevation, t_CKFLOAT azimuth, const string & filename );

private:
    // data
    t_CKINT m_chans;
};




//-----------------------------------------------------------------------------
// name: load()
// desc: load HRIR associated with elevation and azimuth; returns success/fail
//-----------------------------------------------------------------------------
bool Binaural::load( t_CKFLOAT elevation, t_CKFLOAT azimuth, const string & filename )
{
    return true;
}




//-----------------------------------------------------------------------------
// query function: chuck calls this when loading the Chugin
//-----------------------------------------------------------------------------
CK_DLL_QUERY( Binaural )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Binaural");

    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Binaural", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, binaural_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, binaural_dtor);

    // add tick function for mono(in) / stereo(out)
    QUERY->add_ugen_funcf(QUERY, binaural_tickf, NULL, 1, 2);

    // load( float, float, string )
    QUERY->add_mfun(QUERY, binaural_load, "int", "param");
    // add arguments
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->add_arg(QUERY, "float", "azimuth");
    QUERY->add_arg(QUERY, "string", "filename");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    binaural_data_offset = QUERY->add_mvar(QUERY, "int", "@b_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}




// implementation for the constructor
CK_DLL_CTOR(binaural_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, binaural_data_offset) = 0;

    // instantiate our internal c++ class representation
    Binaural * b_obj = new Binaural();

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, binaural_data_offset) = (t_CKINT) b_obj;
}




// implementation for the destructor
CK_DLL_DTOR(binaural_dtor)
{
    // get our c++ class pointer
    Binaural * b_obj = (Binaural *) OBJ_MEMBER_INT(SELF, binaural_data_offset);
    // check it
    if( b_obj )
    {
        // clean up
        delete b_obj;
        OBJ_MEMBER_INT(SELF, binaural_data_offset) = 0;
        b_obj = NULL;
    }
}




// implementation for tick function
CK_DLL_TICKF(binaural_tickf)
{
    // get our c++ class pointer
    Binaural * b = (Binaural *)OBJ_MEMBER_INT(SELF, binaural_data_offset);

    // invoke our tick function; store in the magical out variable
    if(b) b->tick(in, out, nframes);

    // yes
    return TRUE;
}




// load HRIR for elevation/azimuth
CK_DLL_MFUN(binaural_load)
{
    // get argument values
    t_CKFLOAT elevation = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT azimuth = GET_NEXT_FLOAT(ARGS);
    string filename = GET_NEXT_STRING_SAFE(ARGS);
    
    // get our c++ class pointer
    Binaural * b = (Binaural *)OBJ_MEMBER_INT(SELF, binaural_data_offset);
    
    // call it
    b->load( elevation, azimuth, filename );
}
