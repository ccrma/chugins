//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"
#include "abl_link_instance.hpp"

// general includes
#include <stdio.h>
#include <limits.h>

// declaration of chugin constructor
CK_DLL_CTOR(abletonlink_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(abletonlink_dtor);

// example of getter/setter
CK_DLL_MFUN(abletonlink_setEnabled);
CK_DLL_MFUN(abletonlink_setTempo);
CK_DLL_MFUN(abletonlink_setQuantum);
CK_DLL_MFUN(abletonlink_setResolution);
CK_DLL_MFUN(abletonlink_setOffset);
CK_DLL_MFUN(abletonlink_setReset);

CK_DLL_MFUN(abletonlink_getTempo);
CK_DLL_MFUN(abletonlink_getQuantum);
CK_DLL_MFUN(abletonlink_getResolution);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(abletonlink_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT abletonlink_data_offset = 0;

// TODO: create mode switch to output different values: beat, sub-beat, phase, time
// TODO: set offset with a duration instead of float
// TODO: trigger events directly from UGen?

class AbletonLink
{
public:
    // constructor
    AbletonLink( t_CKFLOAT fs)
    {
        steps_per_beat = 1;
        prev_beat_time = 0;
        quantum = 4;
        tempo = 0;
        outval = 0;
        double initial_tempo = 120.0;
        link = abl_link::AblLinkWrapper::getSharedInstance(initial_tempo);
        link->enable(TRUE);
        }

    // for Chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
      std::chrono::microseconds curr_time;
      auto& timeline = link->acquireAudioTimeline(&curr_time);
      if (tempo < 0) {
        timeline.setTempo(-tempo, curr_time);
      }
      const double prev_tempo = tempo;
      tempo = timeline.tempo();
      if (prev_tempo != tempo) {
        printf("Setting tempo to %f\n",tempo);
      }
      double curr_beat_time;
      curr_beat_time = timeline.beatAtTime(curr_time, quantum);
      //outlet_float(beat_out, curr_beat_time);
      const double curr_phase = fmod(curr_beat_time, quantum);
      //outlet_float(phase_out, curr_phase);
      if (curr_beat_time > prev_beat_time) {
        const double prev_phase = fmod(prev_beat_time, quantum);
        const double prev_step = floor(prev_phase * steps_per_beat);
        const double curr_step = floor(curr_phase * steps_per_beat);
        if (prev_phase - curr_phase > quantum / 2 || prev_step != curr_step) {
          outval = curr_step;
        }
      }
      prev_beat_time = curr_beat_time;
      link->releaseAudioTimeline();

      return outval;
    }

    float getTempo() {return tempo;}
    float getQuantum() {return quantum;}
    float getResolution() {return steps_per_beat;}

    int setEnabled (t_CKINT p)
    {
      link->enable(p);
      return p;
    }

    float setTempo (t_CKFLOAT p)
    {
      tempo = -p;
      return p;
    }

    int setQuantum (t_CKINT p)
    {
      quantum = p;
      return p;
    }

    int setResolution (t_CKINT p)
    {
      steps_per_beat = p;
      return p;
    }

    float setOffset (t_CKFLOAT offset_ms)
    {
      link->set_offset(offset_ms);
      return offset_ms;
    }

    int setReset (t_CKINT p)
    {
      std::chrono::microseconds curr_time;
      auto& timeline = link->acquireAudioTimeline(&curr_time);
      if (tempo < 0) {
        timeline.setTempo(tempo, curr_time);
      }
      const double prev_tempo = tempo;
      tempo = timeline.tempo();
      if (prev_tempo != tempo) {
        printf("Setting tempo to %f\n",tempo);
      }
      double curr_beat_time;
      timeline.requestBeatAtTime(prev_beat_time, curr_time, quantum);
      curr_beat_time = timeline.beatAtTime(curr_time, quantum);
      prev_beat_time = curr_beat_time - 1e-6;
      return p;
    }

private:
    // instance data
    int steps_per_beat;
    double prev_beat_time;
    int quantum;
    double tempo;
    double outval;
    std::shared_ptr<abl_link::AblLinkWrapper> link;
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( AbletonLink )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "AbletonLink");

    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "AbletonLink", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, abletonlink_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, abletonlink_dtor);

    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, abletonlink_tick, NULL, 1, 1);

    QUERY->add_mfun(QUERY, abletonlink_setEnabled, "int", "enable");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, abletonlink_setTempo, "float", "tempo");
    QUERY->add_arg(QUERY, "float", "arg");

    QUERY->add_mfun(QUERY, abletonlink_setQuantum, "int", "quantum");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, abletonlink_setResolution, "int", "resolution");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, abletonlink_setOffset, "float", "offset");
    QUERY->add_arg(QUERY, "float", "arg");

    QUERY->add_mfun(QUERY, abletonlink_setReset, "int", "reset");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, abletonlink_getTempo, "float", "tempo");
    QUERY->add_mfun(QUERY, abletonlink_getQuantum, "int", "quantum");
    QUERY->add_mfun(QUERY, abletonlink_getResolution, "int", "resolution");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    abletonlink_data_offset = QUERY->add_mvar(QUERY, "int", "@al_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(abletonlink_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, abletonlink_data_offset) = 0;

    // instantiate our internal c++ class representation
    AbletonLink * al_obj = new AbletonLink(API->vm->get_srate(API, SHRED));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, abletonlink_data_offset) = (t_CKINT) al_obj;
}


// implementation for the destructor
CK_DLL_DTOR(abletonlink_dtor)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // check it
    if( al_obj )
    {
        // clean up
        delete al_obj;
        OBJ_MEMBER_INT(SELF, abletonlink_data_offset) = 0;
        al_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(abletonlink_tick)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);

    // invoke our tick function; store in the magical out variable
    if(al_obj) *out = al_obj->tick(in);

    // yes
    return TRUE;
}



// example implementation for getter
CK_DLL_MFUN(abletonlink_getTempo)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_float = al_obj->getTempo();
}

CK_DLL_MFUN(abletonlink_getQuantum)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_int = al_obj->getQuantum();
}

CK_DLL_MFUN(abletonlink_getResolution)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_int = al_obj->getResolution();
}

// example implementation for setter
CK_DLL_MFUN(abletonlink_setEnabled)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_int = al_obj->setEnabled(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(abletonlink_setTempo)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_float = al_obj->setTempo(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(abletonlink_setQuantum)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_int = al_obj->setQuantum(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(abletonlink_setResolution)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_int = al_obj->setResolution(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(abletonlink_setOffset)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_float = al_obj->setOffset(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(abletonlink_setReset)
{
    // get our c++ class pointer
    AbletonLink * al_obj = (AbletonLink *) OBJ_MEMBER_INT(SELF, abletonlink_data_offset);
    // set the return value
    RETURN->v_int = al_obj->setReset(GET_NEXT_INT(ARGS));
}
