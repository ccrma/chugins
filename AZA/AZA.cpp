//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "AZA", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (AZA.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a AZA-test.ck boilerplate ChucK program
//      to help test your chugin (see AZA-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------
#include "chugin.h"

// Valley
#include "Valley/Plateau/Dattorro.hpp"
#include "Valley/dsp/modulation/LinearEnvelope.hpp"

// Geodesics
#include "Geodesics/EnergyOsc.hpp"

// SoLoud
#define SPEECH_IMPLEMENTATION
#include "single_header/speech.h"

#include <cstdio>
#include <cmath>

// Chugin Helpers ============================================================

#define BEGIN_CLASS(type, base) QUERY->begin_class(QUERY, type, base)
#define END_CLASS() QUERY->end_class(QUERY)
#define CTOR(func) QUERY->add_ctor(QUERY, func)
#define DTOR(func) QUERY->add_dtor(QUERY, func)
#define MVAR(type, name, is_const) QUERY->add_mvar(QUERY, type, name, is_const)
#define MFUN(func, ret, name) QUERY->add_mfun(QUERY, func, ret, name)
#define SFUN(func, ret, name) QUERY->add_sfun(QUERY, func, ret, name)
#define SVAR(type, name, val) QUERY->add_svar(QUERY, type, name, true, val)
#define ARG(type, name) QUERY->add_arg(QUERY, type, name)
#define DOC_FUNC(doc) QUERY->doc_func(QUERY, doc)
#define DOC_CLASS(doc) QUERY->doc_class(QUERY, doc)
#define DOC_VAR(doc) QUERY->doc_var(QUERY, doc)
#define ADD_EX(path) QUERY->add_ex(QUERY, path)
#define TICKF(func, in_channels, out_channels) QUERY->add_ugen_funcf(QUERY, func, NULL, in_channels, out_channels)
#define TICK(func) QUERY->add_ugen_func(QUERY, func, NULL, 1, 1) // for mono UGens

#define GET_NEXT_INT_ARRAY(ptr) (*((Chuck_ArrayInt **&)ptr)++)
#define GET_NEXT_INT_ARRAY(ptr) (*((Chuck_ArrayInt **&)ptr)++)
#define GET_NEXT_FLOAT_ARRAY(ptr) (*((Chuck_ArrayFloat **&)ptr)++)
#define GET_NEXT_VEC2_ARRAY(ptr) (*((Chuck_ArrayVec2 **&)ptr)++)
#define GET_NEXT_VEC3_ARRAY(ptr) (*((Chuck_ArrayVec3 **&)ptr)++)
#define GET_NEXT_VEC4_ARRAY(ptr) (*((Chuck_ArrayVec4 **&)ptr)++)
#define GET_NEXT_OBJECT_ARRAY(ptr) (*((Chuck_ArrayInt **&)ptr)++)
#define GET_NEXT_STRING(ptr) (*((Chuck_String **&)ptr)++)

#define CK_TYPE_VOID "void"
#define CK_TYPE_INT "int"
#define CK_TYPE_FLOAT "float"

#define ASSERT(expression)                                                  \
    if (!(expression))                                                      \
    {                                                                       \
        printf("Assertion(%s) failed: file \"%s\", line %d\n", #expression, \
               __FILE__, __LINE__);                                         \
    }

#define ARRAY_LENGTH(array) (sizeof(array) / sizeof((array)[0]))
#define MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MAX(a, b) (((a) > (b)) ? (a) : (b))
#define CLAMP(x, lo, hi) (MIN(hi, MAX(lo, x)))
#define CLAMP01(x) (MIN(1.f, MAX(0.f, x)))

float lerp(float x, float a, float b)
{
    return a + x * (b - a);
}

float invLerp(float x, float a, float b)
{
    return (x - a) / (b - a);
}

float rescale(float x, float a, float b, float c, float d)
{
    return lerp(invLerp(x, a, b), c, d);
}

// VCV Rack conversion helpers =====================================
struct AZA_Helpers
{
    static float referenceFrequency; // C4; frequency at which Rack 1v/octave CVs are zero.
    static float referenceFrequency_midi;
    static float log_ref_frequency; // log2(referenceFrequency)

    static float cvToFrequency(float cv)
    {
        return std::pow(2.0f, cv) * referenceFrequency;
    }

    static float freqToCV(float freq)
    {
        return log2(freq) - log_ref_frequency;
    }

    static float mtof(float midi)
    {
        return std::pow(2.f, (midi - referenceFrequency_midi) / 12.f) * referenceFrequency;
    }

    static float ftom(float freq)
    {
        return 12.f * (log2(freq) - log_ref_frequency) + referenceFrequency_midi;
    }

    static float VCVAudioVoltageToSample(float v)
    {
        // Audio signals in VCV are [-5, 5]
        // recales to chuck's expected range [-1, 1]
        return v * .2f;
    }
};

float AZA_Helpers::referenceFrequency = 261.626f;
float AZA_Helpers::referenceFrequency_midi = 60.f;
float AZA_Helpers::log_ref_frequency = log2(AZA_Helpers::referenceFrequency);

// ==================================================================

CK_DLL_INFO(AZA)
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo(QUERY, CHUGIN_INFO_CHUGIN_VERSION, "v0.0.0");
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo(QUERY, CHUGIN_INFO_AUTHORS, "Andrew Zhu Aday");
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo(QUERY, CHUGIN_INFO_DESCRIPTION, "AZA Collection");
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo(QUERY, CHUGIN_INFO_URL, "");
    // (optional) contact email
    QUERY->setinfo(QUERY, CHUGIN_INFO_EMAIL, "");
}

CK_DLL_CTOR(plateau_ctor);
CK_DLL_DTOR(plateau_dtor);
CK_DLL_TICKF(plateau_tick);

CK_DLL_MFUN(plateau_set_dry);
CK_DLL_MFUN(plateau_get_dry);
CK_DLL_MFUN(plateau_set_wet);
CK_DLL_MFUN(plateau_get_wet);
CK_DLL_MFUN(plateau_set_hold);
CK_DLL_MFUN(plateau_get_hold);

CK_DLL_MFUN(plateau_clear);

CK_DLL_MFUN(plateau_get_predelay_time);
CK_DLL_MFUN(plateau_set_predelay_time);

CK_DLL_MFUN(plateau_get_predelay_smoothing);
CK_DLL_MFUN(plateau_set_predelay_smoothing);

CK_DLL_MFUN(plateau_get_size);
CK_DLL_MFUN(plateau_set_size);

CK_DLL_MFUN(plateau_get_size_smoothing);
CK_DLL_MFUN(plateau_set_size_smoothing);

CK_DLL_MFUN(plateau_get_diffusion);
CK_DLL_MFUN(plateau_set_diffusion);

CK_DLL_MFUN(plateau_get_decay);
CK_DLL_MFUN(plateau_set_decay);

CK_DLL_MFUN(plateau_get_inputLow);
CK_DLL_MFUN(plateau_set_inputLow);
CK_DLL_MFUN(plateau_get_inputHigh);
CK_DLL_MFUN(plateau_set_inputHigh);

CK_DLL_MFUN(plateau_get_reverbLow);
CK_DLL_MFUN(plateau_set_reverbLow);
CK_DLL_MFUN(plateau_get_reverbHigh);
CK_DLL_MFUN(plateau_set_reverbHigh);

CK_DLL_MFUN(plateau_get_mod_speed);
CK_DLL_MFUN(plateau_set_mod_speed);
CK_DLL_MFUN(plateau_get_mod_depth);
CK_DLL_MFUN(plateau_set_mod_depth);
CK_DLL_MFUN(plateau_get_mod_shape);
CK_DLL_MFUN(plateau_set_mod_shape);

CK_DLL_MFUN(plateau_get_tuned);
CK_DLL_MFUN(plateau_set_tuned);

CK_DLL_MFUN(plateau_get_diffuse);
CK_DLL_MFUN(plateau_set_diffuse);

// this is a special offset reserved for chugin internal data
t_CKINT plateau_data_offset = 0;

struct Plateau
{
    // CV scaling
    const float sizeMin = 0.0025f;
    const float sizeMax = 4.0f;
    const float decayMin = 0.1f;
    const float decayMax = 0.9999f;
    const float modSpeedMin = 0.f;
    const float modSpeedMax = 1.f;
    const float modDepthMin = 0.f;
    const float modDepthMax = 16.f;
    const float modShapeMin = 0.001f;
    const float modShapeMax = 0.999f;

    float minus20dBGain = 0.1f;

    float wet = 0.5f;
    float dry = 1.f;

    float preDelay_smoothing = 0.0001f;
    float preDelay_curr = 0.f;
    float preDelay_target = preDelay_curr;

    float size = .5f;
    float scaled_size_curr = 1.0f;
    float scaled_size_target = scaled_size_curr;
    float size_smoothing = .0001f;

    float diffusion = 1.f;
    float decay = 0.75f;

    float inputLowCut = 0.f;
    float inputHighCut = 1.f;
    float reverbLowCut = 0.f;
    float reverbHighCut = 1.f;

    float modSpeed = 0.01f;
    float modShape = 0.5f;
    float modDepth = 0.03125f;

    bool freeze = false;
    bool cleared = true;
    bool fadeOut = false;
    bool fadeIn = false;

    Dattorro reverb;
    LinearEnvelope envelope;

    bool tuned = false;
    bool diffuseInput = true;

    Plateau(float sample_rate);
    void tick(SAMPLE *in, SAMPLE *out);
    void onSampleRateChange(float sample_rate);
};

Plateau::Plateau(float sample_rate) : reverb(192000, 16, sizeMax)
{
    onSampleRateChange(sample_rate);
    envelope.setTime(0.004f);
    envelope._value = 1.f;

    { // init reverb tank params
        reverb.freeze(freeze);

        reverb.setInputFilterLowCutoffPitch(10 * inputLowCut);
        reverb.setInputFilterHighCutoffPitch(10 * inputHighCut);
        reverb.enableInputDiffusion(diffuseInput);
        reverb.setDecay(decay);

        reverb.setTankDiffusion(10 * diffusion);

        reverb.setTankFilterLowCutFrequency(10 * reverbLowCut);
        reverb.setTankFilterHighCutFrequency(10 * reverbHighCut);

        reverb.setTankModSpeed(modSpeed * modSpeed * 99.f + 1.f);
        reverb.setTankModDepth(rescale(modDepth, 0.f, 1.f, modDepthMin, modDepthMax));
        reverb.setTankModShape(rescale(modShape, 0.f, 1.f, modShapeMin, modShapeMax));
    }
}

void Plateau::tick(SAMPLE *in, SAMPLE *out)
{
    { // clear logic
        if (fadeOut && envelope._justFinished)
        {
            reverb.clear();
            fadeOut = false;
            fadeIn = true;
            envelope.setStartEndPoints(0.f, 1.f);
            envelope.trigger();
        }
        if (fadeIn && envelope._justFinished)
        {
            fadeIn = false;
            cleared = true;
            envelope._value = 1.f;
        }
        envelope.process();
    }

    // update reverb params
    {
        // interpolate size_curr torwards target
        if (tuned)
        {
            scaled_size_target = sizeMin * powf(2.f, size * 5.f);
            scaled_size_target = CLAMP(scaled_size_target, sizeMin, 2.5f);
        }
        else
        {
            scaled_size_target = rescale(size * size, 0.f, 1.f, 0.01f, sizeMax);
            scaled_size_target = CLAMP(scaled_size_target, 0.01f, sizeMax);
        }
        scaled_size_curr = scaled_size_curr + size_smoothing * (scaled_size_target - scaled_size_curr);
        reverb.setTimeScale(scaled_size_curr);

        preDelay_curr = preDelay_curr + preDelay_smoothing * (preDelay_target - preDelay_curr);
        reverb.setPreDelay(preDelay_curr);
    }

    float leftInput = CLAMP(in[0], -1.f, 1.f);
    float rightInput = CLAMP(in[1], -1.f, 1.f);

    // reverb.process(leftInput * minus20dBGain * envelope._value,
    //                rightInput * minus20dBGain * envelope._value);
    reverb.process(leftInput * envelope._value,
                   rightInput * envelope._value);

    float wet_scale = 1.f; // taken from Plateau.cpp L314
    SAMPLE left_wet = wet_scale * reverb.getLeftOutput() * wet * envelope._value;
    SAMPLE right_wet = wet_scale * reverb.getRightOutput() * wet * envelope._value;

    SAMPLE leftOutput = leftInput * dry + left_wet;
    SAMPLE rightOutput = rightInput * dry + right_wet;

    out[0] = CLAMP(leftOutput, -1.f, 1.f);
    out[1] = CLAMP(rightOutput, -1.f, 1.f);
}

void Plateau::onSampleRateChange(float sample_rate)
{
    reverb.setSampleRate(sample_rate);
    envelope.setSampleRate(sample_rate);
}

// ==============================
// Geodesics Energy
// ==============================

struct Geodesics_Energy_Chugin // suffix Chugin to avoid naming collisions
{
    // UGens --------------------------
    FMOp oscM; // size N_POLY
    FMOp oscC; // size N_POLY

    // No need to save, no reset
    float slewInput = 1.f;
    SlewLimiter multiplySlewer;
    uint8_t sample_count; // #samples processed, used as a refresh counter so OK if it overflows and wraps

    // FM Timbre
    float M_feedback;
    float C_feedback;

    // Frequency
    float M_freq;
    float C_freq;
    float freq = AZA_Helpers::referenceFrequency_midi; // final midi is freq + M_freq, freq + C_freq

    Geodesics_Energy_Chugin(float sample_rate) : oscM(sample_rate), oscC(sample_rate)
    {
        // configButton(CROSS_PARAM, "Momentum crossing");
        // configParam(MOMENTUM_PARAMS + 0, 0.0f, 1.0f, 0.0f, "Momentum M");
        // configParam(MOMENTUM_PARAMS + 1, 0.0f, 1.0f, 0.0f, "Momentum C");
        // configParam(FREQ_PARAMS + 0, -3.0f, 3.0f, 0.0f, "Freq M");
        // configParam(FREQ_PARAMS + 1, -3.0f, 3.0f, 0.0f, "Freq C");
        // configButton(ROUTING_PARAM, "Routing");
        // configButton(PLANCK_PARAMS + 0, "Quantize (Planck) M");
        // configButton(PLANCK_PARAMS + 1, "Quantize (Planck) C");
        // configButton(MODTYPE_PARAMS + 0, "CV mod type M");
        // configButton(MODTYPE_PARAMS + 1, "CV mod type C");

        // configInput(FREQCV_INPUTS + 0, "Mass");
        // configInput(FREQCV_INPUTS + 1, "Speed of light");
        // configInput(FREQCV_INPUT, "1V/oct");
        // configInput(MULTIPLY_INPUT, "Multiply");
        // configInput(MOMENTUM_INPUTS + 0, "Momentum M");
        // configInput(MOMENTUM_INPUTS + 1, "Momentum C");

        onSampleRateChange(sample_rate);
        onReset();
    }

    void onReset()
    {
        oscM.onReset();
        oscC.onReset();
    }

    void onSampleRateChange(float sampleRate)
    {
        oscM.onSampleRateChange(sampleRate);
        oscC.onSampleRateChange(sampleRate);
        // setParams2(float sampleRate, float millisecondsUp, float millisecondsDown, float range)
        multiplySlewer.setParams2(sampleRate, 2.5f, 20.0f, 1.0f);
    }

    SAMPLE tick()
    {
        // pitch modulation and feedbacks
        if (sample_count++ & 0x3) // every 4 samps
        {
            { // calcFeedbacks(c); // feedback (momentum), a given channel is updated at sample_rate / 4
              // feedbacks[0][chan] = clamp(feedbacks[0][chan], 0.0f, 1.0f);
              // feedbacks[1][chan] = clamp(feedbacks[1][chan], 0.0f, 1.0f);
            }
        }

        // calculate pitch voltage from params
        // const float vocts[2] = {modSignals[0][c] + inputs[FREQCV_INPUT].getVoltage(c), modSignals[1][c] + inputs[FREQCV_INPUT].getVoltage(c)};
        float m_pitch_voct = AZA_Helpers::freqToCV(AZA_Helpers::mtof(freq + M_freq));
        float c_pitch_voct = AZA_Helpers::freqToCV(AZA_Helpers::mtof(freq + C_freq));

        // update oscillator freq
        // float FMOp::step(float voct, float momentum, float fmDepth, float fmInput)
        // float oscMout = oscM.step(vocts[0], feedbacks[0][c] * 0.3f);
        // float oscCout = oscC.step(vocts[1], feedbacks[1][c] * 0.3f);
        float oscMout = oscM.step(m_pitch_voct, M_feedback * 0.3f);
        float oscCout = oscC.step(c_pitch_voct, C_feedback * 0.3f);

        // multiply (slewInput clamepd between 0,1)
        float multiplySlewValue = multiplySlewer.next(slewInput) * 0.2f;

        // final attenuverters
        float attv1 = oscCout * oscCout * multiplySlewValue;
        float attv2 = attv1 * oscMout * 0.2f;
        return AZA_Helpers::VCVAudioVoltageToSample(attv2);
    }
};

t_CKINT geodesics_energy_data_offset = 0;

CK_DLL_CTOR(geodesics_energy_ctor);
CK_DLL_DTOR(geodesics_energy_dtor);
CK_DLL_TICK(geodesics_energy_tick);

CK_DLL_MFUN(geodesics_energy_get_freq);
CK_DLL_MFUN(geodesics_energy_set_freq);
CK_DLL_MFUN(geodesics_energy_get_freq_m);
CK_DLL_MFUN(geodesics_energy_set_freq_m);
CK_DLL_MFUN(geodesics_energy_get_freq_c);
CK_DLL_MFUN(geodesics_energy_set_freq_c);

CK_DLL_MFUN(geodesics_energy_get_feedback_m);
CK_DLL_MFUN(geodesics_energy_set_feedback_m);
CK_DLL_MFUN(geodesics_energy_get_feedback_c);
CK_DLL_MFUN(geodesics_energy_set_feedback_c);

CK_DLL_MFUN(geodesics_energy_get_multiply);
CK_DLL_MFUN(geodesics_energy_set_multiply);

// using Energy in different modes

// Routing
// 1: freq adds to both M and C
// 2: freq adds to M, -freq to C
// 3: freq to M only

// Planck modes (for quantizing frequency)
// 1: no quantizatoin
// 2: quantize to semitones
// 3: quantize to P5, P8

// frequency CV mode type: amp, add
// add means we add to cv_in + M_freq
// amp means we multiply cv_in * M_freq

// ==============================
// SoLoud Speech
// ==============================

t_CKINT soloud_speech_data_offset = 0;
CK_DLL_CTOR(soloud_speech_ctor);
CK_DLL_DTOR(soloud_speech_dtor);
CK_DLL_TICKF(soloud_speech_tick);

CK_DLL_MFUN(soloud_speech_gen);

CK_DLL_MFUN(soloud_speech_get_freq);
CK_DLL_MFUN(soloud_speech_set_freq);
CK_DLL_MFUN(soloud_speech_get_rate);
CK_DLL_MFUN(soloud_speech_set_rate);
CK_DLL_MFUN(soloud_speech_get_declination);
CK_DLL_MFUN(soloud_speech_set_declination);

CK_DLL_QUERY(AZA)
{
    QUERY->setname(QUERY, "AZA");

    { // Plateau
        BEGIN_CLASS("Plateau", "UGen");
        DOC_CLASS("Valley Plateau (https://valleyaudio.github.io/rack/plateau/) is a lush plate reverb based on the famous, Dattorro (1997) design. "
                  "See their webpage for more info.");

        plateau_data_offset = MVAR("int", "@plateau_data", false);

        CTOR(plateau_ctor);
        DTOR(plateau_dtor);

        TICKF(plateau_tick, 2, 2);

        MFUN(plateau_get_dry, "float", "dry");
        MFUN(plateau_set_dry, CK_TYPE_VOID, "dry");
        ARG(CK_TYPE_FLOAT, "level");
        DOC_FUNC("level clamped to [0, 1]");

        MFUN(plateau_get_wet, "float", "wet");
        MFUN(plateau_set_wet, "void", "wet");
        ARG("float", "level");
        DOC_FUNC("level clamped to [0, 1]");

        MFUN(plateau_get_hold, "int", "hold");
        MFUN(plateau_set_hold, "void", "hold");
        ARG("int", "latch");
        DOC_FUNC("if true, sets the decay of the reverb to infinite so that it will continuously reverberate.");

        MFUN(plateau_clear, "void", "clear");
        DOC_FUNC(" Purges the reverberator. Useful for creating gated reverb effects, or diminshing complete chaos.");

        MFUN(plateau_get_predelay_time, "float", "delay");
        DOC_FUNC("Get pre-delay time in seconds");

        MFUN(plateau_set_predelay_time, "void", "delay");
        ARG("float", "time_secs");
        DOC_FUNC("Set pre-delay time in seconds. Clamped to [0,1]");

        MFUN(plateau_get_predelay_smoothing, "float", "delaySmoothing");
        MFUN(plateau_set_predelay_smoothing, "void", "delaySmoothing");
        ARG("float", "alpha");
        DOC_FUNC("The interpolation factor used to smoothly transition between delay amount. Default .0001. Set closer to 1 for more instantaneous updates, at the cost of introducing crunchy distortion from skipping too far in the delay line");

        MFUN(plateau_get_size, "float", "size");
        MFUN(plateau_set_size, "void", "size");
        ARG("float", "size");
        DOC_FUNC("Sets the overall delay time and apparent 'size' of the reverb. Ranges from very short to extremely long. Clamped to [0,1]");

        MFUN(plateau_get_size_smoothing, "float", "sizeSmoothing");

        MFUN(plateau_set_size_smoothing, "void", "sizeSmoothing");
        ARG("float", "alpha");
        DOC_FUNC("The interpolation factor used to smoothly transition between reverb sizes. Default .0001. Set closer to 1 for more instantaneous updates, at the cost of introducing crunchy distortion from skipping too far in the delay line");

        MFUN(plateau_get_diffusion, "float", "diffusion");

        MFUN(plateau_set_diffusion, "void", "diffusion");
        ARG("float", "amt");
        DOC_FUNC("Controls how diffused and smeared the reverb is. No diffusion results in audible echoes. Clamped to [0,1]");

        MFUN(plateau_get_decay, "float", "decay");

        MFUN(plateau_set_decay, "void", "decay");
        ARG("float", "amt");
        DOC_FUNC("Sets the speed at which the signal decays over time. The maximum setting results in a long reverb that evolves over time into a very slowly dying cloud of sound. Clamped to [0,1]");

        MFUN(plateau_get_inputLow, "float", "inputLow");
        MFUN(plateau_set_inputLow, "void", "inputLow");
        ARG("float", "amt");
        DOC_FUNC(
            "Sets input filter low cut. Input is normalized and clamped between [0,1]. Internally remapped expontentionally to [14, 14080]hz. "
            "A value of 0 allows all frequencies through, a value of 1 applies a low cut to all frequencies. Raising this value can help reduce reverb muddiness. Default 0.");

        MFUN(plateau_get_inputHigh, "float", "inputHigh");
        MFUN(plateau_set_inputHigh, "void", "inputHigh");
        ARG("float", "amt");
        DOC_FUNC(
            "Sets input filter high cut. Input is normalized and clamped between [0,1]. Internally remapped exponentially to [14, 14080]hz. "
            "A value of 1 allows all frequencies through, a value of 0 applies a high cut to all frequencies. Lowering this value reduces reverb sharpness/brighness. Default 1.");

        MFUN(plateau_get_reverbLow, "float", "reverbLow");
        MFUN(plateau_set_reverbLow, "void", "reverbLow");
        ARG("float", "amt");
        DOC_FUNC("Sets reverberator filter low cut. Input is normalized and clamped between [0,1]. Internally remapped to exponentially [14, 14080]hz. "
                 "A value of 0 allows all frequencies through, a value of 1 applies a low cut to all frequencies. Raising this value can help reduce reverb muddiness. Default 0.");

        MFUN(plateau_get_reverbHigh, "float", "reverbHigh");
        MFUN(plateau_set_reverbHigh, "void", "reverbHigh");
        ARG("float", "amt");
        DOC_FUNC("Sets reverberator filter high cut. Input is normalized and clamped between [0,1]. Internally remapped to expontentially [14, 14080]hz. "
                 "A value of 1 allows all frequencies through, a value of 0 applies a high cut to all frequencies. Lowering this value reduces reverb sharpness/brighness. Default 1.");

        MFUN(plateau_get_mod_speed, "float", "modSpeed");
        MFUN(plateau_get_mod_depth, "float", "modDepth");
        MFUN(plateau_get_mod_shape, "float", "modShape");

        MFUN(plateau_set_mod_speed, "void", "modSpeed");
        ARG("float", "amt");
        DOC_FUNC("input clamped to [0,1]. Controls the speed of the LFOs which modulate the delay times of the all-pass filters in the reverberation tank");

        MFUN(plateau_set_mod_depth, "void", "modDepth");
        ARG("float", "amt");
        DOC_FUNC("input clamped to [0,1]. Controls the modulation depth of the LFOs which modulate the delay times of the all-pass filters in the reverberation tank");

        MFUN(plateau_set_mod_shape, "void", "modShape");
        ARG("float", "amt");
        DOC_FUNC("input clamped to [0,1]. Controls the shape of the LFOs which modulate the delay times of the all-pass filters in the reverberation tank");

        MFUN(plateau_get_tuned, "int", "tuned");
        MFUN(plateau_set_tuned, "void", "tuned");
        ARG("int", "tuned");
        DOC_FUNC("If true, enables Tuned Mode: Shortens the delay times and tunes the all-pass filters to 1V/Oct so that the reverb can be 'played'.");

        MFUN(plateau_get_diffuse, "int", "diffuse");
        MFUN(plateau_set_diffuse, "void", "diffuse");
        ARG("int", "diffuse");
        DOC_FUNC("If true, Enages the input diffusion stage that pre-diffuses and smears the signal before reverberation. Setting to false sharpens the input signal.");

        END_CLASS();
    } // Plateau

    { // Geodesics Energy
        BEGIN_CLASS("Energy", "UGen");
        DOC_CLASS("Port of Geodesics Energy ring modulation oscillator. See https://github.com/MarcBoule/Geodesics/tree/master?tab=readme-ov-file#energy");

        geodesics_energy_data_offset = MVAR("int", "@geodesics_energy_data", false);

        CTOR(geodesics_energy_ctor);
        DTOR(geodesics_energy_dtor);
        TICK(geodesics_energy_tick);

        MFUN(geodesics_energy_get_freq, "float", "midi");
        MFUN(geodesics_energy_set_freq, "void", "midi");
        ARG("float", "midi");
        DOC_FUNC("Sets the base frequency of the oscillator in midi.");

        MFUN(geodesics_energy_get_freq_m, "float", "midiM");
        MFUN(geodesics_energy_set_freq_m, "void", "midiM");
        ARG("float", "midi_offset");
        DOC_FUNC("Sets the offset frequency of the M sinus in midi. Its final frequency will be midi + midiM");

        MFUN(geodesics_energy_get_freq_c, "float", "midiC");
        MFUN(geodesics_energy_set_freq_c, "void", "midiC");
        ARG("float", "midi_offset");
        DOC_FUNC("Sets the offset frequency of the C sinus in midi. Its final frequency will be midi + midiC");

        MFUN(geodesics_energy_get_feedback_m, "float", "feedbackM");
        MFUN(geodesics_energy_set_feedback_m, "void", "feedbackM");
        ARG("float", "feedback");
        DOC_FUNC("FM feedback amount of the M sinus. Expected values in [0,1]");

        MFUN(geodesics_energy_get_feedback_c, "float", "feedbackC");
        MFUN(geodesics_energy_set_feedback_c, "void", "feedbackC");
        ARG("float", "feedback");
        DOC_FUNC("FM feedback amount of the C sinus. Expects values in [0,1]");

        MFUN(geodesics_energy_get_multiply, "float", "multiply");
        MFUN(geodesics_energy_set_multiply, "void", "multiply");
        ARG("float", "gain");
        DOC_FUNC("This parameter acts as a VCA. The output audio signal is scaled by this amount, which is internally slew limited so you can use it like an envelope (Open = 1, closed = 0) without audio popping.");

        END_CLASS();
    } // Geodesics Energy

    { // SoLoud Speech
        BEGIN_CLASS("Speech", "UGen");
        DOC_CLASS("TODO");

        soloud_speech_data_offset = MVAR("int", "@soloud_speech_data", false);

        CTOR(soloud_speech_ctor);
        DTOR(soloud_speech_dtor);
        TICKF(soloud_speech_tick, 0, 2);

        MFUN(soloud_speech_gen, "int", "say");
        ARG("string", "text");
        DOC_FUNC("Returns the sample length of the synthesized speech");

        MFUN(soloud_speech_get_freq, "float", "freq");
        DOC_FUNC("Returns the base frequency used to synthesize speech. Default 1330");

        MFUN(soloud_speech_set_freq, "Speech", "freq");
        ARG("float", "freq");
        DOC_FUNC("Set the base frequency used to synthesize speech. Default 1330");

        MFUN(soloud_speech_get_rate, "float", "rate");
        DOC_FUNC("Returns the rate/speed of the synthesized speech. Default 1");

        MFUN(soloud_speech_set_rate, "Speech", "rate");
        ARG("float", "declination");
        DOC_FUNC("Set the rate/speed of the synthesized speech. Default 1");

        MFUN(soloud_speech_get_declination, "float", "declination");
        DOC_FUNC("Returns the declination of the synthesized speech. Default 0.5");

        MFUN(soloud_speech_set_declination, "Speech", "declination");
        ARG("float", "declination");
        DOC_FUNC("Set the declination of the synthesized speech. Default 0.5");

        END_CLASS();
    } // SoLoud Speech

    return true;
}

CK_DLL_CTOR(plateau_ctor)
{
    OBJ_MEMBER_INT(SELF, plateau_data_offset) = 0;
    Plateau *plateau = new Plateau(API->vm->srate(VM));
    OBJ_MEMBER_INT(SELF, plateau_data_offset) = (t_CKINT)plateau;
}

CK_DLL_DTOR(plateau_dtor)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    CK_SAFE_DELETE(plateau);
    OBJ_MEMBER_INT(SELF, plateau_data_offset) = 0;
}

CK_DLL_TICKF(plateau_tick)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    for (int i = 0; i < nframes; i++)
        plateau->tick(in + 2 * i, out + 2 * i);

    return TRUE;
}

CK_DLL_MFUN(plateau_set_dry)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    t_CKFLOAT dry = GET_NEXT_FLOAT(ARGS);
    plateau->dry = CLAMP(dry, 0.f, 1.f);
}

CK_DLL_MFUN(plateau_get_dry)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->dry;
}

CK_DLL_MFUN(plateau_set_wet)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    t_CKFLOAT wet = GET_NEXT_FLOAT(ARGS);
    plateau->wet = CLAMP01(wet);
}

CK_DLL_MFUN(plateau_get_wet)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->wet;
}

CK_DLL_MFUN(plateau_set_hold)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    plateau->freeze = (bool)GET_NEXT_INT(ARGS);
    plateau->reverb.freeze(plateau->freeze);
}

CK_DLL_MFUN(plateau_get_hold)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_int = plateau->freeze ? 1 : 0;
}

CK_DLL_MFUN(plateau_clear)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);

    bool not_in_middle_of_clear = plateau->cleared;
    if (not_in_middle_of_clear)
    {
        plateau->cleared = false;
        plateau->fadeOut = true;
        plateau->envelope.setStartEndPoints(1.f, 0.f);
        plateau->envelope.trigger();
    }
    // remainder of clear is handled in plateau->tick()
}

CK_DLL_MFUN(plateau_get_predelay_time)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->preDelay_target;
}

CK_DLL_MFUN(plateau_set_predelay_time)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float preDelay = GET_NEXT_FLOAT(ARGS);
    plateau->preDelay_target = CLAMP(preDelay, 0.f, 1.f);
}

CK_DLL_MFUN(plateau_get_predelay_smoothing)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->preDelay_smoothing;
}

CK_DLL_MFUN(plateau_set_predelay_smoothing)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    plateau->preDelay_smoothing = GET_NEXT_FLOAT(ARGS);
}

CK_DLL_MFUN(plateau_get_size)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->size;
}

CK_DLL_MFUN(plateau_set_size)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float size = GET_NEXT_FLOAT(ARGS);
    size = CLAMP(size, 0.f, 1.f);
    plateau->size = size;
}

CK_DLL_MFUN(plateau_get_size_smoothing)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->size_smoothing;
}

CK_DLL_MFUN(plateau_set_size_smoothing)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    plateau->size_smoothing = GET_NEXT_FLOAT(ARGS);
}

CK_DLL_MFUN(plateau_get_diffusion)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->diffusion;
}

CK_DLL_MFUN(plateau_set_diffusion)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float diff = GET_NEXT_FLOAT(ARGS);
    diff = CLAMP01(diff);
    plateau->diffusion = diff;

    plateau->reverb.setTankDiffusion(10 * diff);
}

CK_DLL_MFUN(plateau_get_decay)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->decay;
}

CK_DLL_MFUN(plateau_set_decay)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float decay = GET_NEXT_FLOAT(ARGS);
    decay = CLAMP(decay, 0.f, 1.f);
    plateau->decay = decay;

    plateau->reverb.setDecay(decay);
}

CK_DLL_MFUN(plateau_get_inputLow)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->inputLowCut;
}

CK_DLL_MFUN(plateau_set_inputLow)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float lp_cutoff = GET_NEXT_FLOAT(ARGS);
    lp_cutoff = CLAMP01(lp_cutoff);
    plateau->inputLowCut = lp_cutoff;

    plateau->reverb.setInputFilterLowCutoffPitch(10 * lp_cutoff);
}

CK_DLL_MFUN(plateau_get_inputHigh)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->inputHighCut;
}

CK_DLL_MFUN(plateau_set_inputHigh)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float cutoff = GET_NEXT_FLOAT(ARGS);
    cutoff = CLAMP01(cutoff);
    plateau->inputHighCut = cutoff;

    plateau->reverb.setInputFilterHighCutoffPitch(10 * cutoff);
}

CK_DLL_MFUN(plateau_get_reverbLow)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->reverbLowCut;
}

CK_DLL_MFUN(plateau_set_reverbLow)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float lp_cutoff = GET_NEXT_FLOAT(ARGS);
    lp_cutoff = CLAMP01(lp_cutoff);
    plateau->reverbLowCut = lp_cutoff;

    plateau->reverb.setTankFilterLowCutFrequency(10 * lp_cutoff);
}

CK_DLL_MFUN(plateau_get_reverbHigh)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->reverbHighCut;
}

CK_DLL_MFUN(plateau_set_reverbHigh)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float cutoff = GET_NEXT_FLOAT(ARGS);
    cutoff = CLAMP01(cutoff);
    plateau->reverbHighCut = cutoff;

    plateau->reverb.setTankFilterHighCutFrequency(10 * cutoff);
}

CK_DLL_MFUN(plateau_get_mod_speed)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->modSpeed;
}

CK_DLL_MFUN(plateau_set_mod_speed)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float mod = GET_NEXT_FLOAT(ARGS);
    plateau->modSpeed = CLAMP01(mod);

    plateau->reverb.setTankModSpeed(plateau->modSpeed * plateau->modSpeed * 99.f + 1.f);
}

CK_DLL_MFUN(plateau_get_mod_depth)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->modDepth;
}

CK_DLL_MFUN(plateau_set_mod_depth)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float mod = GET_NEXT_FLOAT(ARGS);
    plateau->modDepth = CLAMP01(mod);

    plateau->reverb.setTankModDepth(rescale(plateau->modDepth, 0.f, 1.f, plateau->modDepthMin, plateau->modDepthMax));
}

CK_DLL_MFUN(plateau_get_mod_shape)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_float = plateau->modShape;
}

CK_DLL_MFUN(plateau_set_mod_shape)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    float mod = GET_NEXT_FLOAT(ARGS);
    plateau->modShape = CLAMP01(mod);

    plateau->reverb.setTankModShape(rescale(plateau->modShape, 0.f, 1.f, plateau->modShapeMin, plateau->modShapeMax));
}

CK_DLL_MFUN(plateau_get_tuned)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_int = plateau->tuned ? 1 : 0;
}

CK_DLL_MFUN(plateau_set_tuned)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    plateau->tuned = (bool)GET_NEXT_INT(ARGS);
}

CK_DLL_MFUN(plateau_get_diffuse)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    RETURN->v_int = plateau->diffuseInput ? 1 : 0;
}

CK_DLL_MFUN(plateau_set_diffuse)
{
    Plateau *plateau = (Plateau *)OBJ_MEMBER_INT(SELF, plateau_data_offset);
    plateau->diffuseInput = (bool)GET_NEXT_INT(ARGS);
    plateau->reverb.enableInputDiffusion(plateau->diffuseInput);
}

// Geodesics Energy ===========================================

CK_DLL_CTOR(geodesics_energy_ctor)
{
    OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset) = (t_CKINT) new Geodesics_Energy_Chugin(API->vm->srate(VM));
}

CK_DLL_DTOR(geodesics_energy_dtor)
{
    Geodesics_Energy_Chugin *chugin = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    CK_SAFE_DELETE(chugin);
    OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset) = 0;
}

CK_DLL_TICK(geodesics_energy_tick)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    *out = energy->tick();
    return TRUE;
}

CK_DLL_MFUN(geodesics_energy_get_freq)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    RETURN->v_float = energy->freq;
}

CK_DLL_MFUN(geodesics_energy_set_freq)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    energy->freq = GET_NEXT_FLOAT(ARGS);
}

CK_DLL_MFUN(geodesics_energy_get_freq_m)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    RETURN->v_float = energy->M_freq;
}

CK_DLL_MFUN(geodesics_energy_set_freq_m)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    energy->M_freq = GET_NEXT_FLOAT(ARGS);
}

CK_DLL_MFUN(geodesics_energy_get_freq_c)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    RETURN->v_float = energy->C_freq;
}

CK_DLL_MFUN(geodesics_energy_set_freq_c)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    energy->C_freq = GET_NEXT_FLOAT(ARGS);
}

CK_DLL_MFUN(geodesics_energy_get_feedback_m)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    RETURN->v_float = energy->M_feedback;
}

CK_DLL_MFUN(geodesics_energy_set_feedback_m)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    energy->M_feedback = GET_NEXT_FLOAT(ARGS);
}

CK_DLL_MFUN(geodesics_energy_get_feedback_c)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    RETURN->v_float = energy->C_feedback;
}

CK_DLL_MFUN(geodesics_energy_set_feedback_c)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    energy->C_feedback = GET_NEXT_FLOAT(ARGS);
}

CK_DLL_MFUN(geodesics_energy_get_multiply)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    // RETURN->v_float = energy->multiplySlewer._last; // slewed value
    RETURN->v_float = energy->slewInput;
}

CK_DLL_MFUN(geodesics_energy_set_multiply)
{
    Geodesics_Energy_Chugin *energy = (Geodesics_Energy_Chugin *)OBJ_MEMBER_INT(SELF, geodesics_energy_data_offset);
    energy->slewInput = GET_NEXT_FLOAT(ARGS);
}

// ==================================
// SoLoud Speech
// ==================================

struct SoLoud_Speech_Chugin
{
    short *buff = NULL;
    int buff_nframes = 0; // number of frames in buff, buff length is buff_nframes*2 because stereo
    int buff_read_pos = 0;

    float freq = 1330.0f;
    float rate = 1.0f;
    float declination = 0.5f;
};

// temporary
static short soloud_speech_buff[1024 * 1024] = {};
static uint64_t soloud_speech_read_pos = 0;
static uint64_t soloud_speech_write_pos = 0;

CK_DLL_CTOR(soloud_speech_ctor)
{
    // just stores pointer to speech sample buffer
    OBJ_MEMBER_INT(SELF, soloud_speech_data_offset) = (t_CKINT) new SoLoud_Speech_Chugin;
}

CK_DLL_DTOR(soloud_speech_dtor)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    if (speech->buff)
        speech_free(speech->buff, NULL);
    CK_SAFE_DELETE(speech);
    OBJ_MEMBER_INT(SELF, soloud_speech_data_offset) = 0;
}

CK_DLL_TICKF(soloud_speech_tick)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    for (int i = 0; i < nframes; i++)
    {
        // break out if we reached end of synthesized speech buffer
        if (speech->buff_read_pos >= speech->buff_nframes * 2)
            break;

        (out + 2 * i)[0] = (float)speech->buff[speech->buff_read_pos] / (SHRT_MAX + 1);
        (out + 2 * i)[1] = (float)speech->buff[speech->buff_read_pos + 1] / (SHRT_MAX + 1);
        speech->buff_read_pos += 2;
    }

    return TRUE;
}

CK_DLL_MFUN(soloud_speech_gen)
{
    Chuck_String *ck_string = GET_NEXT_STRING(ARGS);
    if (!ck_string)
        return;
    const char *text = API->object->str(ck_string);

    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);

    // free old buff, if exists
    if (speech->buff)
        speech_free(speech->buff, NULL);

    speech->buff = speech_gen(
        &speech->buff_nframes, text, NULL,
        speech->freq,
        speech->rate,
        speech->declination);

    // ASSERT(samples_pairs_generated % 2 == 0);

    // reset read head
    speech->buff_read_pos = 0;

    RETURN->v_int = speech->buff_nframes;
}

CK_DLL_MFUN(soloud_speech_get_freq)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    RETURN->v_float = speech->freq;
}

CK_DLL_MFUN(soloud_speech_set_freq)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    speech->freq = GET_NEXT_FLOAT(ARGS);
    RETURN->v_object = SELF;
}

CK_DLL_MFUN(soloud_speech_get_rate)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    RETURN->v_float = speech->rate;
}

CK_DLL_MFUN(soloud_speech_set_rate)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    speech->rate = GET_NEXT_FLOAT(ARGS);
    RETURN->v_object = SELF;
}

CK_DLL_MFUN(soloud_speech_get_declination)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    RETURN->v_float = speech->declination;
}

CK_DLL_MFUN(soloud_speech_set_declination)
{
    SoLoud_Speech_Chugin *speech = (SoLoud_Speech_Chugin *)OBJ_MEMBER_INT(SELF, soloud_speech_data_offset);
    speech->declination = GET_NEXT_FLOAT(ARGS);
    RETURN->v_object = SELF;
}
