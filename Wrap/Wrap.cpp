/*
 * Wrap UGen - wraps audio signals
 * based on Pure Data wrap~
 * 
 * @author      Mario Buoninfante
 * @year        2020
*/


//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>

// declaration of chugin constructor
CK_DLL_CTOR(wrap_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(wrap_dtor);

// example of getter/setter
CK_DLL_MFUN(wrap_setParam);
CK_DLL_MFUN(wrap_getParam);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(wrap_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT wrap_data_offset = 0;


// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class Wrap
{
public:
    // constructor
    Wrap( t_CKFLOAT fs)
    {
        int_input = 0;
    }
    
    SAMPLE tick( SAMPLE in )
    {
        int_input = (int) in;
        if (int_input <= in)    
            return in-int_input;
        else                    
            return in - (int_input-1);
    }

private:
    int int_input;
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Wrap )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Wrap");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Wrap", "UGen");

    QUERY->add_ctor(QUERY, wrap_ctor);
    QUERY->add_dtor(QUERY, wrap_dtor);
    
    QUERY->add_ugen_func(QUERY, wrap_tick, NULL, 1, 1);
    
    
    wrap_data_offset = QUERY->add_mvar(QUERY, "int", "@w_data", false);

    QUERY->end_class(QUERY);

    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(wrap_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, wrap_data_offset) = 0;
    
    // instantiate our internal c++ class representation
    Wrap * w_obj = new Wrap(API->vm->get_srate(API, SHRED));
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, wrap_data_offset) = (t_CKINT) w_obj;
}


// implementation for the destructor
CK_DLL_DTOR(wrap_dtor)
{
    // get our c++ class pointer
    Wrap * w_obj = (Wrap *) OBJ_MEMBER_INT(SELF, wrap_data_offset);
    // check it
    if( w_obj )
    {
        // clean up
        delete w_obj;
        OBJ_MEMBER_INT(SELF, wrap_data_offset) = 0;
        w_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(wrap_tick)
{
    // get our c++ class pointer
    Wrap * w_obj = (Wrap *) OBJ_MEMBER_INT(SELF, wrap_data_offset);
 
    // invoke our tick function; store in the magical out variable
    if(w_obj) *out = w_obj->tick(in);

    // yes
    return TRUE;
}
